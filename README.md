# spikeSorter

8/1/2019

This process relays on several steps handled by different scripts:

1. Set experiment information, handled by makeExpermientFile.mat: This first scripts takes the binnary data file and some user input to create am experiment.mat file that contains information important to extract spikes form the recording. This file includes information about the prove. Namely, number of channels and an order index for each channel that will arrange them in 1 dimension. This order is important in that it determines which channels neighboor each other which impacts on the effects of artifitial refractory periods (see notes on spikesFunction). In addition, the output file of this function includes a threshold for spike detection in each channel (set manually by the user based on first 60sec of recording) and a boolean array indicating bad channels that should be discarded (also set by the user after being presented first 60s of recording).

2. Detect spikes and extract spike properties, handled by spikesFunction.mat: This function will extract spikes from the raw data using the information provided by experiment.mat. The function does not process the entire data at once. Instead, it will only process a subset of the data (across recording time) based on the JobID input (the only input variable of the function). This allows analysis to be done job by job in a single computer that could not load all of the experiment raw data in memory. It also allows for a cluster to run different JobIDs in parallel on different computers to speed up processing time. Experiment file includes the name of the experiment to be analyze by spikeFunction, this was done for convenience when using a cluster to analyze data as only the experiment file and expeiment data folder needs to be load onto the cluster root when analyzing a new experiment instead of needing to feed the function a different value for a "filename" input variable. It is important to consider that this function implements an artifitial refractory period that spans a pre-fixed number of samples across time and a pre-fixed number of recording sites (electrodes) across the one-dimensional order provided by experiment.mat. This may not be ideal for probe configurations where distances across electrodes vary across the specified one dimensional order (for example if two shanks are present, an artifitial refractory period due to a detected spike in the last recording site of shank 1 should not be applied to the first one in shank 2 as the distance between shanks make it highly unlikely that the same spike will be detected in both recording sites). Ideally, artificitial refractory periods should span a fixed amount of time (in msec) and space (in um). Then, the code would consider the geometry of the probe to decide which channels should be influenced by artifical refractory periods triggered by a spike in a given channel based on individual channel distances. An efficient way of implementing this is not straight forward but I will be working on it as an update to the Isis code version, which already takes into account probe geometry in 2 dimensional space (see Isis branch notes). Once spikes are detected, spikesFunction will calculate a number of pre-set spike properties including peak-to-peak amplitude across the detected channel and channels neighboring the detected channel, energy, width of depolarization half-maximum etc. This information is saved in an output file called spikesFile. A spikesFile will be created for each JobID and will have to be merged together for a complete list of spikes detected across the entire experiment.

3. Sort spikes, handled by sortGUI: This is the GUI that will implement manual sorting. The feature of this gui that allows for reasonably quick manual sorting is the addition of a spike property named "Position". A spike position is a property computed by spikesFunction that essentially uses the amplitud of a spike in its detected and surrounding channels to assign a position to the spike along the one-dimensional axis given by the order of channels set in experiment.mat. It calculates this position by simply computing the center of mass of peak-to-peak amplitude of the spike in different channels. This feature is made much nicer by the Isis updated version where spike amplitudes in different channels are assigned a 2-dimensional x-y position given the probe geometry. Therefore, spike position in the Isis version is 2-dimensional allowing for more precise sorting. By projecting spike position vs spike amplitude at detecred channel using sortGUi, clusters of spikes with amplitudes that clearly stand out from smaller unsortable spikes can be quickly recognized and sorted along different parts of the probe. By projecting spike position vs amplitude at channels neighbooring the detected channel additional clusters may be detected which correspond to spikes that are not big enough to be sorted in the detected channel but stand out by having a larger amplitude on surrounding channels. Clusters of spikes that are first sorted in this way, can be sorted further by comparing spike amplitude across different neighboring channel as one would do when sorting tetrode data. Finally, spikes can be sorted based on shape by using properties such as energy, peak-to-peak amplitude and spike width. This step of the manual sorting is usually useful at cleaning spikes with anomalous shapes that may correspond to noise instead of actual spikes. An additional spike property that user may find useful is the "channel width". This property looks at the amplitude of a spike in its detected channel (where it is the biggest) and divides it by the sum of the amplitude across all channels. Both spikes that only show up in the detected channel (Channel width = 1) on a probe densely packed with recording sites as well as spikes that do not decrease in aplitude as one considers channel far away from the detected channel (Channel width ~0) may represent noise instead of real spikes. SortGUI saves the user sorted data by changind the cluster identity number on the variable idk which is stored in the spikesFile. This data, along with timestamps for the spikes, can then be used to compute single unit responses.

Additional features and possible applications:

Motion detection and correction: The addition of a spike position property in this analysis allows for post-processing analysis of probe movement during the recording session. When visualizing spike position vs spike time using SortGUI, the user can identify a patern of "more populated" and "less populated" areas of the probe where more or less spikes are detected. If the probe moves during the recording, sites that were positioned on more populated areas of cortex (where more spikes occur) sill shift to rurrounding areas that are less populated. This can be observed using sortGUI when plting spike position vs spike time as the profile of spikes densiti along the probe shifts as time increases. This can be differentiates from changes in overal activity levels due to brain state changes where the overal density of spikes may quickly change along the entire probe without any obvious shift of the spatial arrangment of spikes density. In recordings where slow probe motion occured (1-3 channels across the entire session) it wouls be possible to analyze the shift in the spikes density profile along theprobe to and use it to correct the spike position for spikes detected at different times to correct for this displacement. While this motion will still make it impossible to sort spikes based on modes differences in amplitudes on different channels (because this is constantly changing due to motion), large spikes that can be reliably sorted based on amplitude in a single channel across the experiment may be recovered by correcting the effect of probe displacement. That said, my personal advise is to discard any recording that shows significant signs of displacement.

Before runing sorting code in a new PC:


Steps to sort spikes:

1. Copy your data folder into your "expFolder": 
expFolder is a variable containing a path that is stored on the Settings.mat file in clusterSpikesProbe folder where several of the scripts for dealing with multichannel probes data are. Not to be confused with the Settings file under the Settings.mat file in ProbeManualSorting folder which contains settings for the sorting gui. When you install these script in a new machine you will have to change some variables in that settings file.

2. Make experiment mat file: This file is made by "makeExperimentFile.m". This script needs manual input of experiment name and probe class. It then presents the first minute of recording to the user for it to decide the threshold for spike detection and indicate which channels are bad. This file will contain information about the experiment required to process the experiment in the cluster.  It contains: 
   - a1 and b1: Bandpass filter to filter raw data. 
   - BadCh: a boolean vector indicating whether a channel is bad or not.
   - CHs: The order of the channels in the probe, it is decided based on the probe following some track starting from the base to the tip of the probe.
   - experiment: the experiment name.
   - Th: unique threshold to detect spikes on any channel that is not bad.

3. The experiment file needs to be copied into  "/home/alempel1/spikesFromProbe" replacing  any previous experiment file. Also the experiment folder (which includes the raw data) needs to be copied to the same folder. 

4. Submit the "spikesSubmitScript.submit" to the cluster: From the Terminal input:
   - ssh 'user'@'ip adress
   - cd spikesFromProbe
   - condor_submit spikesSubmitScript.submit
   - This script will run spikesFuncition in 200 instances. Each instance gets a 1/200 fraction of the file to be processed (with some overlay between fractions so that if a spike gets detected at the end of one the samples needed for the waveform are available and spike don’t get detected at the ends of the fraction if it is not the minimum in the appropriate window). This detection works exactly the same as SpikesIntan script. When the minimum is searched for across channels it will only consider channels that are +/- 4 channels (unlike the SpikesIntan script which does it across all channels).

5. Merge spikes files: The cluster will output 200 files into the 'SpikeFiles" folder in the experiment folder that you copied to the cluster. These files contain the spike information for spikes detected in each fraction of the recording. This files are merged in a unique spikes file using script "mergeSpikesFiles". The merged file will include a matrix call "Properties" a vector called "idk" and a cell called "PropTitles". The "Properties" vector includes a number of properties for each detected spike. The spike waveforms are not handled by the spike detection algorithm as the files would be to heavy and hard to work with.  The cell PropTitles indicate which property is included in the Properties matrix. These may change but at the moment they include: 
   - Amp(0): amplitude (minimum value minus baseline) at the channel of detection (the one with the minimum value).
   - Amp(-4 to 4): value at sample 16 (detected minimum of spike) for those channels neighboring the channel of detection (4 channels up to 4 channels down the order given by the probe type. When a spike is detected at the end of a probe and a channel in some direction does not exist, that amplitude is set to 0.
   - Pk2Pk Amp: Amplitude at detection channel given as minimum - post valley instead of - baseline. Energy: Energy of  the spike waveform (41 samples as described in SpikesIntan) at the channel of detection.
   - Wvf width: Width of waveform at the channel of detection, post valley position is determined as the first local maxima after sample 16 (where the minimum is).
   - CHs Width: Calculated as Amp(0) divided by sum of all Amps. Gives a metric of how wide is the spike across channels of the probe.
   - CH Pos: The position of the spike across the probe measured as the center of mass of the spike across channels -1 to 1 (detected +/- 1).
   - Timestamp: sample of detection.
   - CH detected: The channel were the spice is detected.
Finally, idk is a vector of length = number of detected spikes that is initialized as all zeros.

6. Sort your spikes using "sortGUI" which essentially makes changes to "idk".
7. Once done you need to run "makeSpikesFiles" which will ask you the experiment name. It will then use the digital input information of the experiment to get all the trial information. Then, it loads your sorted spikes file to get all the sorting information and creates the Spike structure (Like SpikesIntan but this one will leave the Waveforms part empty as there is no available waveforms). Once this is done it creates a "…_Spikes" file under the "spikesFolder" path loaded from the settings file containing this information plus the sorting information. After that it will load the experiment Analyzer file, calculate the data file (Like sorter or SortV2 but this one does not assume sampling frequency) and save it and if the user decide will also write the info in the summary file (the path and file ending of all these files being loaded and created are set by variables stored in the settings file).
